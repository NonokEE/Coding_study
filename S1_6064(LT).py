import sys
ip = sys.stdin.readline

tc = int(ip())
for _ in range(tc):
    m, n, x, y = map(int, ip().split())
    remainder_list = []
    remainder = 0
    i = 0

    while 1:
        remainder = (m*i+x-y)%n

        if remainder == 0: 
            flag = True    #나누어 떨어짐을 나타내는 플래그
            break
        else             : 
            if remainder not in remainder_list:  #나머지 중복이 없으면 계속 탐색
                remainder_list.append(remainder)    
                remainder = 0
            else: #나머지 중복 발생시 중단
                flag = False
                break
        i += 1

    if flag: print(m*i+x)
    else   : print(-1)


''' 카잉 달력
M과 N보다 작거나 같은 두 개의 자연수 x, y를 가지고 x:y같은 식으로 년도를 표기함
첫 번째 해를 1:1로, 두번쨰 해를 2:2로 표현.
x:y의 다음 해를 x':y'라고 할 때, x<M이라면 x'=x+1이고, 그렇지 않다면 x'=1이다. y도 마찬가지.
-> 1부터 M까지 루프한다는 뜻

M:N이 마지막해라고 한다.
M:10, N=12라면 첫 해는 1:1, 11번째 해는 1:11, 3:1은 13번쨰 해. 마지막해인 10:12는 60번째.

각 M, N, x, y의 TC에 대해서 x:y가 몇 번쨰 해인지 구하라.
만약 불가능하면 -1 출력

- 입력 -
첫 줄에 TC 개수 T
이후 T개동안 M N x y가 주어짐

시간 1초, 메모리 256MB

--2트--
무한루프 함부로 쓰지 마라
사실 방법 자체는 틀리진 않았는데, 더 효율적인 뭔가 뭔가가 있는 것 같음.

1. (M,x) (N,y)는 서로 바꿔줘도 됨
N이 무식하게 크다든지 하면 비효율적으로 돌아가는 케이스도 있을 것.
ex)
10 1024 2 4같은거라면?

2. M이나 N을 줄일 수 있는 방법이 있을 것으로 보임
공약수나 공배수 구해서 효율적으로 한다든지.

(M*i + x - y)%N 라는 수식이 핵심
(N*j + y - x)%M

3. 아니면 다른 방법도 있을 수 있겠다
이거 모듈러 들어가는 모양이 어째 이산수학 같은데

(M*i + x - y)%N ->
(M*i + x) === y(mod N) 이라는거지?

쓸 수 

--1트--: 시간초과
두 숫자가 같이 올라가는데 M, N진수라는거지
그냥 수학 문제 같은데.

M에서 x가 가능하려면 
ex) m = 10, x= 3
3, 13, 23, ...
x, x+m, x+2m

A번째 해가 y려면
ex) n = 10, y = 5
A = i*n + y를 만족해야 한다.

근데 문제상 불가능한 경우도 있다고 하니 그것을 어떤 수학적인 방법으로 찾아낼 것인가가 문제.

10 12 3 9 -> 33이라는데
10 3일때 3 13 23 33 43 ... 가능
이 중 33 = 12 * 2 + 9라서 33이 나온다.

10 12 7 2 -> -1이라는데
마찬가지로 3 13 23 33

오 그럼 저렇게 수열 뽑았을 때, 그 수열에서 y를 빼고 그 중에서 n의 배수가 있는지 알아보면 되겠다.
ex)
 3 13 23 33 43
-6  4 14 24 34

배수가 가능한지 불가능한지는 어떻게 알아보는가? 무한히 뽑다가 알아볼 수는 없잖아?
4 14 24 34를 7로 계속 나눠보다보면 나머지가 반복되는 순간이 올거임. 그러면 절대 만나지 못하고 루프한다는 뜻
조금 멍청하긴 한데, 이것 말고는 방법이 없다.

1. (M*i + x - y)를 N으로 나눈다. (x == y인 경우 그냥 x가 답인거 염두)
    1-1. 나눠떨어지면 답 구하기로 ㄱㄱ
2. 나머지를 리스트에 기록한다.
3. 나머지가 리스트에 중복되지 않을 때 까지 i를 늘려가면서 반복
4. M*i + x가 답이다.
'''