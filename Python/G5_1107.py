import sys
ip = sys.stdin.readline

n = int(ip())
m = int(ip())
broken = []
if m: 
    broken = list(map(int, ip().split()))

res = abs(n - 100) # +-만 가지고 이동하는 경우를 일단 최솟값으로 책정

for channel in range(1000001):      #0번 채널부터 1,000,000번 채널까지
    for digit in str(channel):      #문자열화 하고 고장났는지 확인
        if int(digit) in broken:    #고장났으면 넘겨
            break
    else:                       #고장안났으면 그 채널의 클릭 수를 최소값으로.
        val = len(str(channel)) + abs(channel - n)
        res = min(res, val)
            
print(res)



''' 리모컨
시간 2초 메모리 256MB

0~9번 버튼, +, -가 있다. 
플마 누르면 +1 -1로 채널 이동, 채널 0에서 - 누르면 아무일 없음.
채널은 무한대 만큼 있다.

N채널로 이동하고 싶다 치고
어떤 버튼이 고장났는지 주어졌을 때, 
채널 N으로 이동하기 위해 버튼을 최소 몇번 눌러야하는지 구하셈

초기 채널 시작은 100번 채널


- 입력 -
첫 줄에목적지 채널 N(0이상 500,000이하)
둘째 줄에 고장난 버튼 개수 M(0이상 10이하)
고장난 버튼이 있는 경우에만 세번째 줄 들어오고, 어떤 버튼 고장났는지 주어짐. 중복은 X

--2트--
아예 방법을 다르게 생각해야 한다.
저런 스마~트한 방법으로 하려고 하지 말고, 냥꾼처럼 무식하게 찾자. 브루트포스잖아
틀리면 서치 좀 똑똑하게 해보고, 그래도 안되면 답지 본다

--1트--: 틀렸습니다
오랜만에 무식한 문제가 나온 것 같습니다. 탐색 알고리즘 아닌거같음.
시간이 꽤 널널하다

1. 고장난 버튼이 없다면
목적지 채널의 자릿수 vs (목적채널 - 현재 채널) 중 작은거

2. 고장난게 있다면
가능한 경우 다 해보는게 낫나?

12345로 가는데
3 4가 고장났다 치고

1. 안고장난 자리수는 넘기기

12까지는 패스

3이 고장났으니 3을 +1하거나 -1 한다.

+1한 경우는 뒷자리를 0으로, 불가능하면 1, 2, 3 이렇게 올려줌
-1한 경우는 뒷자리를 

+1이랑 -1도 불가능하면 +2, +3 이렇게 감.

만약
9000 인데 9가 고장났으면?
8888로은 가능하고
10000으로 해줘야지


'''