import sys
ip = sys.stdin.readline

n = int(ip())
a = list(map(int, ip().split()))
dp = [1 for _ in range(n)]

for i in range(n):
    for j in range(i):
        if a[j] < a[i]:
            dp[i] = max(dp[i], dp[j]+1)

print(max(dp))

''' 가장 긴 증가하는 부분 수열
시간 1초 메모리 256MB

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하라

- 입력 -
수열 길이 n
수열 내용

- 출력-
가장 긴 증가하는 부분 수열 길이

--1트--: 결과
이게 그 LCS 문제 하위문제인 것 같은데, 이걸 어떻게 DP로 할지 모르겠단 말이지
dp[i] = a[i]를 마지막 값으로 가지는 갖아 긴 증가부분수열의 길이 
a[i]가 마지막 값이 되려면 a[i] 이전의 마지막 값이 a[i]보다 작아야 한다.
그리고 그 길이는 a[i]이전 가장 긴 값 + 1

즉, 조건이 맞으면 그 단계에서 가장 큰 값은 이전에 계산한 것 중 제일 큰 값임.
최댓값 갱신하는걸 좀 센스있게 했을 뿐이지.
a[i]를 끝으로 할 때, dp[0], dp[1] ... 지금까지 계산 해놨잖아? 
dp[0] + a[i]가 가능한가, dp[1] + a[i]가 가능한가를 판별해서 가능하면 +1 해주는거지.

ㅇㅋ 이해했음

O N^2이 틀린게 아니구나? 그럴 수 밖에 없구나?
'''