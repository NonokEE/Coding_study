import sys
ip = sys.stdin.readline

n = int(ip())
m = int(ip())
s = list(" ".join((ip().strip())).split())

for i in range(m):
    if s[i] == 'I': s[i] = 1
    else          : s[i] = 0

count = 0
i = 0
while i < m - 2*n:
  a = 0
  if s[i] == 1:
    while ((s[i+(2*a + 1)]==0) and (s[i+(2*a + 2)]==1)) and (i+(2*a + 2) < m): # 1로 시작한 부분 뒤에 0과 1이 반복되는 횟수를 기록하여 pa를 확인
      a += 1
    if a >= n: #pa가 pn보다 크거나 같다면 카운트 늘려줌
      count += (a - n + 1)
  i+= (1 + 2*a)

print(count)

''' IOIOI

P1 = IOI
P2 = IOIOI
P3 = IOIOIOI
입니다.

문자열 S와 정수 N을 줄거니까 S 안에 PN이 몇개 들어가는지 세세요.
P1인데 IOIOI면 2개 들어간거임.

- 입력 -
첫줄에 N, 둘째줄에 S길이, 셋째줄에 S

--3트--: 런타임 ㅋㅋ
더 효율적인 순회나 검사가 필요한 것으로 보입니다.

1. 1로 시작한다고 다 검사 돌릴 필요가 없다. 다음이 0이 아니면 무의미.
2. 오토마타를 따로 구현할 필요도 없다. 순회중에 바로바로 확인 가능.

PN이란, 1로 시작하고 01이 N번 반복되는 문자열이다.
1이 나오면 다음에 0 1이 반복되는지 확인.
즉 P몇인지 확인

P5라고 치자.
P5일 때 P1은 몇개 들어가는가

10101010101
101
  101
    101
      101
        101

5개 들어감.
P5안에 P1은 5개
P5안에 P2는 4개
P5안에 P3는 3개
PA안에 PN은 A-N+1개 들어간다.
지금 문자열에서 PA가 어디에 있고, 얼마나 긴지 안다면 오토마타로 확인할 필요도 없음.

--2트--: 50점
경계값이 이상하네
1 3 IOI면 1이잖아? s 입력은 잘 들어가는데 오토마타가 뭐가 이상한듯
순회 범위가 틀렸네요~

--1트--: 왜 틀려
오토마타로 구현하면 문제는 간단함. 

1. IOI오토마타 만든다
2. 문자열 순회하면서 I면 오토마타에 넣는다.
3. 끗

PN의 길이는 2N+1이므로, S의 끝에서 2N+1 이후 부터는 순회할 필요 없다.
m - n 까지만 루프.

0123456
1010101 7
101 3
'''