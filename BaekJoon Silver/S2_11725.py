import sys
ip = sys.stdin.readline

N = int(ip())
graph = {i:[] for i in range(1, N+1)} #인접리스트

for _ in range(N-1):
    n1, n2 = map(int, ip().split())
    graph[n1].append(n2)
    graph[n2].append(n1)

res = [0 for _ in range(N+1)]         #탐색결과 저장용. res[i] = i의 부모
visited = [False for _ in range(N+1)]
dfs_stack = [1]

while dfs_stack:
    cur = dfs_stack.pop()
    visited[cur] = True
    for child in graph[cur]:
        if not visited[child]:
            dfs_stack.append(child)
            res[child] = cur

for i in range(2, N+1):
    print(res[i])

''' 트리의 부모 찾기
시간 1초 메모리 256MB

루트없는 트리를 줄거에요. 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하세요.

- 입력 -
첫 줄에 노드 개수 N
둘째 줄 부터 연결 구조

- 출력-
2번노드부터 끝 노드까지 부모 출력
(1번은 루트니까 출력 없습니다)

--4트--: 클
이거 입력이 너무 많을 수 있어서 저렇게 루프 돌리면 터질 가능성 농후함.
일단 입력은 그래프로 다 받고 거기서부터 찾는게 낫다.

입력에서 부모자식 구분이 안되니까 연결정보를 양쪽에 넣어주고, 중복만 아니면 됨.

--3트--: 시간초과
저 로직으로는 누락이 되는 경우가 있다는거임
12345 이렇게 들어오는건 맞는데, 중간에 누군가가 부모 입력이 안된다는거지.

12
56
이면 56은 어디로 들어가야됨? 
그리고 56에서 5가 부모라고 하더라도 6이 자식이라는 보장은 없음. 6이 5의 부모일 수도 있다.

즉 저 로직으로 공란이 생기는 이유가, 부모자식 구분이 제대로 안돼서 트리에 추가되지 않고 갱신된다는거임.
'a가 누군가의 부모면 b는 a의 자식이다' 이 부분이 잘못됨.
'a가 누군가의 자식이면 a는 b의 부모다' 이건 성립함.

두번째 식으로 가능하면 넣어준다. 아니라면 후순위로 밀어서 다시 시도.
단, 둘 중에 1이 있다면 걔는 무조건 1이 부모니까 그냥 넣어주면 된다.
될때까지 넣는다.

--2트--: 왜 틀?
키 에러가 났다는건 상정 못한 경우가 있다는건데 그게 가능해?
N=2인 경우
1 2밖에 없을 것이고
한 노드가 여러 부모를 가질 수는 없다.
로직 자체는 문제가 없는데,
키 에러? 노드 번호가 꼭 순차적으로 들어온다고 한 적은 없지..? 2 10 30 이렇게 들어올 수도 있는거 아닌가?


--1트--: 키 에러
간단하게 딕셔너리로 안되려나?
되기야는 하는데, 입력에서 어느쪽이 부모고 자식인지 알 수 없음.

새로 추가되는거니까, 무조건 한 쪽은 이미 있는거고 한 쪽은 없는거임!
없는 쪽이 자식노드다.
가 아닐 수도 있다.

한쪽이 확실히 부모면 상관없는데, 아직 부모자식이 확실하지 않은 경우가 있다.
둘 다 부모가 아닌 경우면 무조건 한쪽은 새로운 노드고 한쪽은 기존에 있던 노드다.
누군가의 자식인 쪽이 부모가 되면 됨

'''